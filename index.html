<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Studio Professional</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-dark: #1a1a1a;
            --secondary-dark: #2d2d2d;
            --accent-dark: #3a3a3a;
            --border-color: #404040;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --accent-blue: #007acc;
            --accent-green: #28a745;
            --accent-red: #dc3545;
            --accent-orange: #fd7e14;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-dark);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex; /* Use flexbox to center content vertically/horizontally */
            flex-direction: column;
        }

        .app-container {
            display: grid;
            grid-template-areas:
                "header header header"
                "toolbar canvas properties"
                "layers canvas properties";
            grid-template-columns: 60px 1fr 280px;
            grid-template-rows: 50px 1fr auto;
            height: calc(100vh - 24px); /* Account for status bar height */
        }

        /* Header */
        .header {
            grid-area: header;
            background: var(--secondary-dark);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .header-btn:hover {
            background: var(--accent-dark);
            color: var(--text-primary);
        }

        .header-btn.primary {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* Toolbar */
        .toolbar {
            grid-area: toolbar;
            background: var(--secondary-dark);
            border-right: 1px solid var(--border-color);
            padding: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .tool-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
            width: 100%;
            align-items: center;
        }

        .tool-group:last-child {
            border-bottom: none;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            position: relative;
        }

        .tool-btn:hover {
            background: var(--accent-dark);
            color: var(--text-primary);
        }

        .tool-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }

        .tool-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--primary-dark);
            border: 1px solid var(--border-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }

        .tool-btn:hover::after {
            opacity: 1;
        }

        /* Canvas Area */
        .canvas-area {
            grid-area: canvas;
            background: var(--accent-dark);
            display: flex;
            align-items: center; /* Center canvas vertically */
            justify-content: center; /* Center canvas horizontally */
            position: relative;
            overflow: hidden; /* Important for bounding pan/zoom */
            cursor: default; /* Default cursor, tools change it */
        }

        .canvas-wrapper {
            position: relative;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            /* Add transitions for smooth pan/zoom */
            transition: transform 0.05s ease-out;
            transform-origin: 0 0; /* Important for consistent zoom/pan */
            will-change: transform; /* Optimize for animation */
        }

        #canvas {
            display: block;
            border-radius: 8px;
            /* Cursors set by JS based on active tool */
        }

        .canvas-overlay {
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            pointer-events: none;
        }

        /* Properties Panel */
        .properties {
            grid-area: properties;
            background: var(--secondary-dark);
            border-left: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
        }

        .property-section {
            margin-bottom: 25px;
        }

        .property-section h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .property-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .property-label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .property-input {
            background: var(--accent-dark);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            width: 60px;
            text-align: center;
        }

        .property-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .color-picker {
            width: 40px;
            height: 28px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }

        .slider-container {
            flex: 1;
            margin-left: 15px;
        }

        .slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--accent-dark);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .brush-preview {
            width: 80px;
            height: 40px;
            background: var(--accent-dark);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 8px;
        }

        .brush-dot {
            background: var(--text-primary);
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .blend-modes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .blend-btn {
            background: var(--accent-dark);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 6px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .blend-btn:hover,
        .blend-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }

        /* Layers Panel */
        .layers {
            grid-area: layers;
            background: var(--secondary-dark);
            border-right: 1px solid var(--border-color);
            border-top: 1px solid var(--border-color);
            height: 200px;
            padding: 15px;
        }

        .layers h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: var(--accent-dark);
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .layer-item:hover {
            background: var(--border-color);
        }

        .layer-item.active {
            background: var(--accent-blue);
        }

        .layer-preview {
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 2px;
            margin-right: 8px;
            border: 1px solid var(--border-color);
        }

        .layer-name {
            flex: 1;
            font-size: 12px;
        }

        .layer-opacity {
            font-size: 10px;
            color: var(--text-secondary);
        }

        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px;
            background: var(--primary-dark);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 15px;
            font-size: 11px;
            color: var(--text-secondary);
            justify-content: space-between;
            opacity: 0.8; /* Increased opacity for better readability */
            z-index: 1001; /* Ensure it's above other elements */
        }

        .status-left,
        .status-right {
            display: flex;
            gap: 15px;
        }

        /* Keyboard Shortcuts */
        .shortcuts {
            position: fixed;
            top: 60px;
            right: 20px;
            background: var(--secondary-dark);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            font-size: 11px;
            color: var(--text-secondary);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .shortcuts.show {
            opacity: 1;
            pointer-events: all;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            min-width: 180px;
        }

        .shortcut-key {
            background: var(--accent-dark);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        /* Tool specific cursors */
        .canvas-area.cursor-brush { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><path fill="currentColor" d="M12 10l-2 2h4l-2-2z"/></svg>') 12 12, crosshair; }
        .canvas-area.cursor-pencil { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M14.06 9.02l.92.92L5.92 18H5v-.92l9.06-9.06m3.61-4.7l-1.08 1.08 2.06 2.06 1.08-1.08c.39-.39.39-1.02 0-1.41l-1.41-1.41c-.39-.39-1.02-.39-1.41 0zM17.81 4.7l-1.08 1.08 2.06 2.06 1.08-1.08c.39-.39.39-1.02 0-1.41l-1.41-1.41c-.39-.39-1.02-.39-1.41 0z"/></svg>') 18 6, default; }
        .canvas-area.cursor-eraser { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M17.8 8.08l-5.06-5.06c-.78-.78-2.05-.78-2.83 0L3.13 10.8c-.78.78-.78 2.05 0 2.83l5.06 5.06c.78.78 2.05.78 2.83 0l6.78-6.78c.78-.78.78-2.05 0-2.83zM6.34 11.21L12 5.56l2.12 2.12L8.46 13.34z"/></svg>') 6 18, default; }
        .canvas-area.cursor-line, .canvas-area.cursor-rectangle, .canvas-area.cursor-circle { cursor: crosshair; }
        .canvas-area.cursor-eyedropper { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1.03 14.93c-.41.41-.95.64-1.54.64-.59 0-1.13-.23-1.54-.64-.82-.82-.82-2.15 0-2.97l5.25-5.25c.82-.82 2.15-.82 2.97 0 .82.82.82 2.15 0 2.97l-5.25 5.25zm-.71-.71l4.54-4.54c.41-.41.41-1.07 0-1.48-.41-.41-1.07-.41-1.48 0l-4.54 4.54c-.41.41-.41 1.07 0 1.48.41.41 1.07.41 1.48 0z"/></svg>') 12 12, default; }
        .canvas-area.cursor-bucket { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9-4.03-9-9-9zm-1 16H8v-2h3v2zm4-2h-3v2h3v-2zm-1-4h-3v2h3v-2zm4-2h-3v2h3v-2zm-1-4h-3v2h3v-2zm4-2h-3v2h3v-2zM7 7h10v10H7V7z"/></svg>') 12 12, default; }
        .canvas-area.cursor-zoom-in { cursor: zoom-in; }
        .canvas-area.cursor-zoom-out { cursor: zoom-out; }
        .canvas-area.cursor-pan { cursor: grab; }
        .canvas-area.cursor-pan.grabbing { cursor: grabbing; }


        @media (max-width: 1024px) {
            .app-container {
                grid-template-columns: 50px 1fr 240px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-areas:
                    "header header"
                    "canvas canvas"
                    "toolbar properties";
                grid-template-columns: 1fr 1fr;
                grid-template-rows: 50px 1fr auto; /* auto for properties height */
                height: calc(100vh - 24px);
            }

            .toolbar {
                flex-direction: row;
                padding: 8px;
                overflow-x: auto;
            }

            .layers {
                display: none;
            }

            .properties {
                min-height: 250px; /* Ensure properties panel has some height */
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="logo">Canvas Studio Professional</div>
            <div class="header-actions">
                <button class="header-btn" id="shortcutsBtn">Shortcuts</button>
                <button class="header-btn" id="newBtn">New</button>
                <button class="header-btn" id="saveBtn">Save</button>
                <button class="header-btn primary" id="exportBtn">Export</button>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-btn active" data-tool="brush" data-tooltip="Brush (B)">üñåÔ∏è</button>
                <button class="tool-btn" data-tool="pencil" data-tooltip="Pencil (P)">‚úèÔ∏è</button>
                <button class="tool-btn" data-tool="eraser" data-tooltip="Eraser (E)">üßΩ</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" data-tool="line" data-tooltip="Line (L)">üìè</button>
                <button class="tool-btn" data-tool="rectangle" data-tooltip="Rectangle (R)">‚ñ≠</button>
                <button class="tool-btn" data-tool="circle" data-tooltip="Circle (C)">‚≠ï</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" data-tool="eyedropper" data-tooltip="Eyedropper (I)">üíß</button>
                <button class="tool-btn" data-tool="bucket" data-tooltip="Fill (F)">ü™£</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" data-tool="zoom" data-tooltip="Zoom (Z)">üîç</button>
                <button class="tool-btn" data-tool="pan" data-tooltip="Pan (H)">‚úã</button>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area" id="canvasArea">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="canvas" width="800" height="500"></canvas>
                <div class="canvas-overlay"></div>
            </div>
        </div>

        <!-- Layers Panel -->
        <div class="layers">
            <h3>Layers</h3>
            <div class="layer-item active">
                <div class="layer-preview"></div>
                <div class="layer-name">Background</div>
                <div class="layer-opacity">100%</div>
            </div>
            <div class="layer-item">
                <div class="layer-preview"></div>
                <div class="layer-name">Layer 1</div>
                <div class="layer-opacity">100%</div>
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="properties">
            <div class="property-section">
                <h3>Canvas</h3>
                <div class="property-row">
                    <span class="property-label">Width</span>
                    <input type="number" class="property-input" id="canvasWidthInput" value="800" min="100" max="4000">
                </div>
                <div class="property-row">
                    <span class="property-label">Height</span>
                    <input type="number" class="property-input" id="canvasHeightInput" value="500" min="100" max="4000">
                </div>
                <div class="property-row">
                    <span class="property-label">Zoom</span>
                    <input type="number" class="property-input" id="zoomInput" value="100" min="10" max="500">
                    <div class="slider-container">
                        <input type="range" class="slider" id="zoomSlider" min="10" max="500" value="100">
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 15px;">
                    <button class="header-btn" id="applyCanvasSizeBtn">Apply Canvas Size</button>
                </div>
            </div>

            <div class="property-section">
                <h3>Brush</h3>
                <div class="property-row">
                    <span class="property-label">Size</span>
                    <input type="number" class="property-input" id="brushSizeInput" value="5" min="1" max="100">
                    <div class="slider-container">
                        <input type="range" class="slider" id="brushSize" min="1" max="100" value="5">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Opacity</span>
                    <input type="number" class="property-input" id="opacityInput" value="100" min="0" max="100">
                    <div class="slider-container">
                        <input type="range" class="slider" id="opacity" min="0" max="100" value="100">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Hardness</span>
                    <input type="number" class="property-input" id="hardnessInput" value="100" min="0" max="100">
                    <div class="slider-container">
                        <input type="range" class="slider" id="hardness" min="0" max="100" value="100">
                    </div>
                </div>
                <div class="brush-preview">
                    <div class="brush-dot" id="brushPreview"></div>
                </div>
            </div>

            <div class="property-section">
                <h3>Colors</h3>
                <div class="property-row">
                    <span class="property-label">Foreground</span>
                    <input type="color" class="color-picker" id="foregroundColor" value="#000000">
                </div>
                <div class="property-row">
                    <span class="property-label">Background</span>
                    <input type="color" class="color-picker" id="backgroundColor" value="#ffffff">
                </div>
            </div>

            <div class="property-section">
                <h3>Blend Mode</h3>
                <div class="blend-modes">
                    <button class="blend-btn active" data-blend="source-over">Normal</button>
                    <button class="blend-btn" data-blend="multiply">Multiply</button>
                    <button class="blend-btn" data-blend="screen">Screen</button>
                    <button class="blend-btn" data-blend="overlay">Overlay</button>
                    <button class="blend-btn" data-blend="darken">Darken</button>
                    <button class="blend-btn" data-blend="lighten">Lighten</button>
                </div>
            </div>

            <div class="property-section">
                <h3>Actions</h3>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <button class="header-btn" id="undoBtn">Undo (Ctrl+Z)</button>
                    <button class="header-btn" id="redoBtn">Redo (Ctrl+Y)</button>
                    <button class="header-btn" id="clearBtn">Clear Canvas</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-left">
            <span id="canvasSize">800 √ó 500 px</span>
            <span id="currentTool">Brush Tool</span>
            <span id="brushInfo">Size: 5px, Opacity: 100%</span>
        </div>
        <div class="status-right">
            <span id="coordinates">0, 0</span>
            <span id="zoomStatus">100% Zoom</span>
        </div>
    </div>

    <!-- Keyboard Shortcuts -->
    <div class="shortcuts" id="shortcuts">
        <div class="shortcut-item">
            <span>Brush Tool</span>
            <span class="shortcut-key">B</span>
        </div>
        <div class="shortcut-item">
            <span>Eraser Tool</span>
            <span class="shortcut-key">E</span>
        </div>
        <div class="shortcut-item">
            <span>Line Tool</span>
            <span class="shortcut-key">L</span>
        </div>
        <div class="shortcut-item">
            <span>Undo</span>
            <span class="shortcut-key">Ctrl+Z</span>
        </div>
        <div class="shortcut-item">
            <span>Redo</span>
            <span class="shortcut-key">Ctrl+Y</span>
        </div>
        <div class="shortcut-item">
            <span>Save</span>
            <span class="shortcut-key">Ctrl+S</span>
        </div>
        <div class="shortcut-item">
            <span>New Canvas</span>
            <span class="shortcut-key">Ctrl+N</span>
        </div>
        <div class="shortcut-item">
            <span>Zoom In</span>
            <span class="shortcut-key">Ctrl++</span>
        </div>
        <div class="shortcut-item">
            <span>Zoom Out</span>
            <span class="shortcut-key">Ctrl+-</span>
        </div>
        <div class="shortcut-item">
            <span>Pan Tool</span>
            <span class="shortcut-key">H</span>
        </div>
    </div>

    <script>
        // Canvas and context
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const canvasArea = document.getElementById('canvasArea');

        // State management
        let isDrawing = false;
        let currentTool = 'brush';
        let currentBlendMode = 'source-over';
        let brushSize = 5;
        let opacity = 100;
        let hardness = 100;
        let foregroundColor = '#000000';
        let backgroundColor = '#ffffff';
        let startX, startY;
        let undoStack = [];
        let redoStack = [];

        // Pan and Zoom state
        let panX = 0;
        let panY = 0;
        let zoomLevel = 1.0; // 1.0 = 100%
        let isPanning = false;
        let panStartX, panStartY; // Mouse position when pan started

        // Initialize canvas
        function initCanvas() {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState();
            updateCanvasTransform();
            updateToolCursor();
        }

        // Save state for undo/redo
        function saveState() {
            // Save the entire canvas as a data URL
            undoStack.push(canvas.toDataURL());
            // Limit undo stack size to prevent excessive memory usage
            if (undoStack.length > 50) undoStack.shift();
            redoStack = []; // Clear redo stack on new action
        }

        // Undo functionality
        function undo() {
            if (undoStack.length > 1) {
                // Move current state to redo stack
                redoStack.push(undoStack.pop());
                // Get the previous state from undo stack
                const imageData = undoStack[undoStack.length - 1];
                const img = new Image();
                img.onload = () => {
                    // Clear canvas and draw the previous state
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = imageData;
            }
        }

        // Redo functionality
        function redo() {
            if (redoStack.length > 0) {
                const imageData = redoStack.pop();
                undoStack.push(imageData); // Move state back to undo stack
                const img = new Image();
                img.onload = () => {
                    // Clear canvas and draw the restored state
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = imageData;
            }
        }

        // Helper to get transformed canvas coordinates from mouse event
        function getTransformedCoords(e) {
            const rect = canvas.getBoundingClientRect();
            // Calculate coordinates relative to the canvas *wrapper* (which is transformed)
            // Then convert those coordinates back to the untransformed canvas space
            const x = (e.clientX - rect.left - panX) / zoomLevel;
            const y = (e.clientY - rect.top - panY) / zoomLevel;
            return { x, y };
        }

        // Drawing functions
        function startDrawing(e) {
            if (currentTool === 'zoom' || currentTool === 'pan') return;

            isDrawing = true;
            const { x, y } = getTransformedCoords(e);
            startX = x;
            startY = y;

            setupBrush();

            if (currentTool === 'brush' || currentTool === 'pencil' || currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                draw(e); // Draw immediate dot/line
            }
        }

        function draw(e) {
            if (!isDrawing || currentTool === 'zoom' || currentTool === 'pan') return;

            const { x, y } = getTransformedCoords(e);
            updateCoordinates(x, y);

            if (currentTool === 'brush' || currentTool === 'pencil') {
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath(); // Start new path for continuous drawing
                ctx.moveTo(x, y);
            } else if (currentTool === 'eraser') {
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath(); // Start new path for continuous erasing
                ctx.moveTo(x, y);
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return; // Prevent saving state if no drawing occurred
            isDrawing = false;

            if (currentTool === 'zoom' || currentTool === 'pan') {
                // Pan/Zoom actions don't save state on mouse up
                return;
            }

            const { x: endX, y: endY } = getTransformedCoords(e);

            if (currentTool === 'line') {
                setupBrush();
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            } else if (currentTool === 'rectangle') {
                setupBrush();
                ctx.beginPath();
                // Ensure correct rectangle drawing for all directions
                const rectX = Math.min(startX, endX);
                const rectY = Math.min(startY, endY);
                const rectWidth = Math.abs(endX - startX);
                const rectHeight = Math.abs(endY - startY);
                ctx.rect(rectX, rectY, rectWidth, rectHeight);
                ctx.stroke();
            } else if (currentTool === 'circle') {
                setupBrush();
                const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                ctx.beginPath();
                ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }

            saveState(); // Save state after a completed drawing action
        }

        function setupBrush() {
            // Set global composite operation for blending or erasing
            ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : currentBlendMode;
            // Eraser uses a transparent color, otherwise use foreground color
            ctx.strokeStyle = currentTool === 'eraser' ? 'rgba(0,0,0,1)' : foregroundColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = opacity / 100; // Apply opacity

            // Apply softness/shadow based on hardness and zoom level
            if (hardness < 100 && currentTool !== 'pencil') {
                // Shadow blur scales with zoom for consistent visual effect
                ctx.shadowColor = currentTool === 'eraser' ? 'rgba(0,0,0,0.5)' : foregroundColor;
                ctx.shadowBlur = ((100 - hardness) / 10) / zoomLevel; // Inverse scaling for shadow blur
            } else {
                ctx.shadowBlur = 0; // No shadow for full hardness or pencil
            }
        }

        // Update coordinate display in status bar
        function updateCoordinates(x, y) {
            document.getElementById('coordinates').textContent = `${Math.round(x)}, ${Math.round(y)}`;
        }

        // Update the CSS transform for pan and zoom
        function updateCanvasTransform() {
            canvasWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
            document.getElementById('zoomStatus').textContent = `${Math.round(zoomLevel * 100)}% Zoom`;
            document.getElementById('zoomInput').value = Math.round(zoomLevel * 100);
            document.getElementById('zoomSlider').value = Math.round(zoomLevel * 100);
            updateBrushPreview(); // Update brush preview as its size depends on zoom
        }

        // Set cursor based on active tool
        function updateToolCursor() {
            const cursorClass = `cursor-${currentTool}`;
            // Remove all cursor classes
            canvasArea.className = 'canvas-area';
            // Add the new cursor class
            canvasArea.classList.add(cursorClass);
        }

        // Event listeners for drawing (general)
        canvas.addEventListener('mousedown', (e) => {
            if (currentTool === 'pan') {
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                canvasArea.classList.add('grabbing'); // Visual feedback for grabbing
            } else if (currentTool === 'zoom') {
                // No specific mousedown action for zoom tool, handled by click or wheel
            } else {
                startDrawing(e);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getTransformedCoords(e);
            updateCoordinates(x, y);

            if (isPanning) {
                // Adjust pan position based on mouse movement
                panX += (e.clientX - panStartX);
                panY += (e.clientY - panStartY);
                panStartX = e.clientX;
                panStartY = e.clientY;
                updateCanvasTransform();
            } else {
                draw(e);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvasArea.classList.remove('grabbing');
            } else {
                stopDrawing(e);
            }
        });

        canvas.addEventListener('mouseout', (e) => {
            // Stop drawing or panning if mouse leaves canvas area
            if (isDrawing) {
                stopDrawing(e);
            }
            if (isPanning) {
                isPanning = false;
                canvasArea.classList.remove('grabbing');
            }
        });

        // Mouse wheel for zooming
        canvasArea.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent page scrolling

            const oldZoomLevel = zoomLevel;
            const zoomAmount = 0.1; // How much to zoom per wheel tick

            // Determine zoom direction
            if (e.deltaY < 0) {
                // Zoom in
                zoomLevel = Math.min(5.0, zoomLevel + zoomAmount);
            } else {
                // Zoom out
                zoomLevel = Math.max(0.1, zoomLevel - zoomAmount);
            }

            // Calculate mouse position relative to canvas wrapper
            const rect = canvasWrapper.getBoundingClientRect();
            const mouseCanvasX = e.clientX - rect.left;
            const mouseCanvasY = e.clientY - rect.top;

            // Adjust pan to zoom around the mouse cursor
            panX = mouseCanvasX - ((mouseCanvasX - panX) * (zoomLevel / oldZoomLevel));
            panY = mouseCanvasY - ((mouseCanvasY - panY) * (zoomLevel / oldZoomLevel));

            updateCanvasTransform();
        });


        // Tool selection
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.tool-btn.active').classList.remove('active');
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                document.getElementById('currentTool').textContent = btn.dataset.tooltip.split(' (')[0] + ' Tool';
                updateToolCursor();
            });
        });

        // Blend mode selection
        document.querySelectorAll('.blend-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.blend-btn.active').classList.remove('active');
                btn.classList.add('active');
                currentBlendMode = btn.dataset.blend;
            });
        });

        // Property controls - Sync sliders and inputs
        function syncSliderAndInput(sliderId, inputId, callback) {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);

            slider.addEventListener('input', (e) => {
                input.value = e.target.value;
                callback(e.target.value);
            });

            input.addEventListener('input', (e) => {
                let value = parseInt(e.target.value);
                // Clamp value to min/max of slider
                value = Math.max(parseInt(slider.min), Math.min(parseInt(slider.max), value));
                input.value = value; // Update input value if it was out of bounds
                slider.value = value;
                callback(value);
            });
        }

        syncSliderAndInput('brushSize', 'brushSizeInput', (value) => {
            brushSize = parseInt(value);
            updateBrushPreview();
            updateBrushInfo();
        });

        syncSliderAndInput('opacity', 'opacityInput', (value) => {
            opacity = parseInt(value);
            updateBrushInfo();
        });

        syncSliderAndInput('hardness', 'hardnessInput', (value) => {
            hardness = parseInt(value);
        });

        // Zoom slider and input sync
        syncSliderAndInput('zoomSlider', 'zoomInput', (value) => {
            const oldZoomLevel = zoomLevel;
            zoomLevel = parseInt(value) / 100; // Convert percentage back to decimal

            // Recalculate pan to keep center
            // This is a simplified centering, a true "zoom around center" requires more complex logic
            // based on the viewport center, but this is good for slider input.
            const currentCanvasWidth = canvas.width * oldZoomLevel;
            const currentCanvasHeight = canvas.height * oldZoomLevel;
            const newCanvasWidth = canvas.width * zoomLevel;
            const newCanvasHeight = canvas.height * zoomLevel;

            // Adjust pan to keep the center of the canvas in view
            panX -= (newCanvasWidth - currentCanvasWidth) / 2;
            panY -= (newCanvasHeight - currentCanvasHeight) / 2;

            updateCanvasTransform();
        });


        function updateBrushPreview() {
            const preview = document.getElementById('brushPreview');
            // Scale brush preview size based on zoom level, but keep it within limits
            const size = Math.max(4, Math.min(30, brushSize * zoomLevel));
            preview.style.width = size + 'px';
            preview.style.height = size + 'px';
            preview.style.backgroundColor = foregroundColor;
        }

        function updateBrushInfo() {
            document.getElementById('brushInfo').textContent = `Size: ${brushSize}px, Opacity: ${opacity}%`;
        }

        // Color pickers
        document.getElementById('foregroundColor').addEventListener('input', (e) => {
            foregroundColor = e.target.value;
            updateBrushPreview();
        });

        document.getElementById('backgroundColor').addEventListener('input', (e) => {
            backgroundColor = e.target.value;
            // Clear canvas and fill with new background color
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState(); // Save this background change as a state
        });

        // Action buttons
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
        document.getElementById('clearBtn').addEventListener('click', () => {
            // Implement a custom modal for confirmation instead of window.confirm
            showCustomConfirmation('Clear Canvas', 'Are you sure you want to clear the entire canvas? This action cannot be undone.', () => {
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                saveState();
            });
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'canvas-artwork.png';
            link.href = canvas.toDataURL(); // Default to PNG
            link.click();
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            // For now, still defaults to PNG, but exportCanvas allows other formats
            exportCanvas('png', 1.0);
        });

        document.getElementById('newBtn').addEventListener('click', () => {
            // Implement a custom modal for confirmation instead of window.confirm
            showCustomConfirmation('New Canvas', 'Create new canvas? This will clear your current work.', () => {
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                undoStack = [];
                redoStack = [];
                saveState();
            });
        });

        // Custom confirmation modal (replaces window.confirm)
        function showCustomConfirmation(title, message, onConfirm) {
            // Create modal elements
            const modalOverlay = document.createElement('div');
            modalOverlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background-color: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background-color: var(--secondary-dark);
                padding: 25px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                max-width: 400px;
                width: 90%;
                color: var(--text-primary);
                font-family: 'Inter', sans-serif;
            `;

            const modalTitle = document.createElement('h3');
            modalTitle.textContent = title;
            modalTitle.style.cssText = `
                margin-bottom: 15px;
                font-size: 16px;
                color: var(--accent-blue);
            `;

            const modalMessage = document.createElement('p');
            modalMessage.textContent = message;
            modalMessage.style.cssText = `
                margin-bottom: 25px;
                font-size: 13px;
                line-height: 1.5;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                justify-content: flex-end;
                gap: 10px;
            `;

            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'Confirm';
            confirmBtn.classList.add('header-btn', 'primary');
            confirmBtn.style.cssText += `
                padding: 8px 15px;
                font-size: 13px;
            `;

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.classList.add('header-btn');
            cancelBtn.style.cssText += `
                padding: 8px 15px;
                font-size: 13px;
            `;

            buttonContainer.appendChild(cancelBtn);
            buttonContainer.appendChild(confirmBtn);
            modalContent.appendChild(modalTitle);
            modalContent.appendChild(modalMessage);
            modalContent.appendChild(buttonContainer);
            modalOverlay.appendChild(modalContent);
            document.body.appendChild(modalOverlay);

            confirmBtn.addEventListener('click', () => {
                onConfirm();
                document.body.removeChild(modalOverlay);
            });

            cancelBtn.addEventListener('click', () => {
                document.body.removeChild(modalOverlay);
            });
        }


        // Shortcuts panel
        document.getElementById('shortcutsBtn').addEventListener('click', () => {
            const shortcuts = document.getElementById('shortcuts');
            shortcuts.classList.toggle('show');
        });

        // Close shortcuts when clicking outside
        document.addEventListener('click', (e) => {
            const shortcuts = document.getElementById('shortcuts');
            const shortcutsBtn = document.getElementById('shortcutsBtn');
            if (!shortcuts.contains(e.target) && !shortcutsBtn.contains(e.target)) {
                shortcuts.classList.remove('show');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Prevent default for our shortcuts
            if (e.ctrlKey || e.metaKey) { // Ctrl for Windows/Linux, Meta for Mac (Command key)
                switch (e.key.toLowerCase()) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) { // Ctrl+Shift+Z for Redo
                            redo();
                        } else { // Ctrl+Z for Undo
                            undo();
                        }
                        break;
                    case 'y': // Ctrl+Y for Redo
                        e.preventDefault();
                        redo();
                        break;
                    case 's': // Ctrl+S for Save
                        e.preventDefault();
                        document.getElementById('saveBtn').click();
                        break;
                    case 'n': // Ctrl+N for New Canvas
                        e.preventDefault();
                        document.getElementById('newBtn').click();
                        break;
                    case '+': // Ctrl++ for Zoom In
                        e.preventDefault();
                        const currentZoomPlus = parseFloat(document.getElementById('zoomSlider').value) / 100;
                        zoomLevel = Math.min(5.0, currentZoomPlus + 0.1);
                        updateCanvasTransform();
                        break;
                    case '-': // Ctrl+- for Zoom Out
                        e.preventDefault();
                        const currentZoomMinus = parseFloat(document.getElementById('zoomSlider').value) / 100;
                        zoomLevel = Math.max(0.1, currentZoomMinus - 0.1);
                        updateCanvasTransform();
                        break;
                }
            } else {
                // Tool shortcuts
                switch (e.key.toLowerCase()) {
                    case 'b':
                        document.querySelector('[data-tool="brush"]').click();
                        break;
                    case 'e':
                        document.querySelector('[data-tool="eraser"]').click();
                        break;
                    case 'p':
                        document.querySelector('[data-tool="pencil"]').click();
                        break;
                    case 'l':
                        document.querySelector('[data-tool="line"]').click();
                        break;
                    case 'r':
                        document.querySelector('[data-tool="rectangle"]').click();
                        break;
                    case 'c':
                        // Only activate circle if no modifier keys are pressed
                        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
                            document.querySelector('[data-tool="circle"]').click();
                        }
                        break;
                    case 'i':
                        document.querySelector('[data-tool="eyedropper"]').click();
                        break;
                    case 'f':
                        document.querySelector('[data-tool="bucket"]').click();
                        break;
                    case 'z':
                        // Only activate zoom tool if no modifier keys (like Ctrl/Cmd for undo) are pressed
                        if (!e.ctrlKey && !e.metaKey) {
                            document.querySelector('[data-tool="zoom"]').click();
                        }
                        break;
                    case 'h':
                        document.querySelector('[data-tool="pan"]').click();
                        break;
                    case '[': // Decrease brush size
                        const currentSize = parseInt(document.getElementById('brushSize').value);
                        const newSize = Math.max(1, currentSize - 5);
                        document.getElementById('brushSize').value = newSize;
                        document.getElementById('brushSizeInput').value = newSize;
                        brushSize = newSize;
                        updateBrushPreview();
                        updateBrushInfo();
                        break;
                    case ']': // Increase brush size
                        const currentSize2 = parseInt(document.getElementById('brushSize').value);
                        const newSize2 = Math.min(100, currentSize2 + 5);
                        document.getElementById('brushSize').value = newSize2;
                        document.getElementById('brushSizeInput').value = newSize2;
                        brushSize = newSize2;
                        updateBrushPreview();
                        updateBrushInfo();
                        break;
                }
            }
        });

        // Touch support for mobile (basic drawing only, pan/zoom handled by gestures or default browser behavior if not overridden)
        let touchStartX, touchStartY;
        let lastTouchX, lastTouchY; // For panning with touch

        canvas.addEventListener('touchstart', (e) => {
            // Prevent default touch behavior (e.g., scrolling, pinch-zoom by browser) for single touch
            // Multi-touch gestures for pan/zoom will be handled by the browser if not explicitly coded.
            if (e.touches.length === 1) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();

                if (currentTool === 'pan') {
                    isPanning = true;
                    panStartX = touch.clientX;
                    panStartY = touch.clientY;
                    canvasArea.classList.add('grabbing');
                } else {
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        bubbles: true, // Allow event to bubble up
                        cancelable: true // Allow event to be cancelled
                    });
                    canvas.dispatchEvent(mouseEvent);
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                e.preventDefault(); // Prevent scrolling while drawing/panning
                const touch = e.touches[0];
                if (isPanning) {
                    panX += (touch.clientX - panStartX);
                    panY += (touch.clientY - panStartY);
                    panStartX = touch.clientX;
                    panStartY = touch.clientY;
                    updateCanvasTransform();
                } else {
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        bubbles: true,
                        cancelable: true
                    });
                    canvas.dispatchEvent(mouseEvent);
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            if (isPanning) {
                isPanning = false;
                canvasArea.classList.remove('grabbing');
            } else {
                const mouseEvent = new MouseEvent('mouseup', {
                    bubbles: true,
                    cancelable: true
                });
                canvas.dispatchEvent(mouseEvent);
            }
        });


        // Eyedropper tool functionality
        function getColorAtPosition(x, y) {
            // Clamp coordinates to canvas bounds to prevent errors
            x = Math.max(0, Math.min(canvas.width - 1, Math.round(x)));
            y = Math.max(0, Math.min(canvas.height - 1, Math.round(y)));

            const imageData = ctx.getImageData(x, y, 1, 1);
            const [r, g, b] = imageData.data;
            // Convert RGB to hex color string
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Bucket fill functionality (Flood Fill)
        function floodFill(startX, startY, fillColor) {
            // Get current canvas pixel data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            // Get the color of the pixel at the starting point
            const targetColor = getPixelColor(imageData, startX, startY);
            // Convert fill color (hex) to RGB array
            const fillColorRgb = hexToRgb(fillColor);

            // If target color is already the fill color, do nothing
            if (colorsMatch(targetColor, fillColorRgb)) return;

            const stack = [[startX, startY]]; // Stack for DFS (Depth-First Search)
            const visited = new Set(); // Keep track of visited pixels to avoid infinite loops

            while (stack.length > 0) {
                const [x, y] = stack.pop(); // Get pixel from stack
                const key = `${x},${y}`; // Unique key for visited set

                // Check bounds and if already visited
                if (visited.has(key) || x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                    continue;
                }

                const currentColor = getPixelColor(imageData, x, y);
                // If current pixel color does not match target color, skip
                if (!colorsMatch(currentColor, targetColor)) continue;

                visited.add(key); // Mark as visited
                setPixelColor(imageData, x, y, fillColorRgb); // Set new color

                // Add neighbors to the stack
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            // Put the modified image data back onto the canvas
            ctx.putImageData(imageData, 0, 0);
        }

        // Get RGB and Alpha components of a pixel from ImageData
        function getPixelColor(imageData, x, y) {
            const index = (y * imageData.width + x) * 4;
            return [
                imageData.data[index],
                imageData.data[index + 1],
                imageData.data[index + 2],
                imageData.data[index + 3]
            ];
        }

        // Set RGB and Alpha components of a pixel in ImageData
        function setPixelColor(imageData, x, y, color) {
            const index = (y * imageData.width + x) * 4;
            imageData.data[index] = color[0];
            imageData.data[index + 1] = color[1];
            imageData.data[index + 2] = color[2];
            imageData.data[index + 3] = 255; // Set alpha to full opaque for simplicity
        }

        // Compare two colors (ignoring alpha for now)
        function colorsMatch(color1, color2) {
            return color1[0] === color2[0] && color1[1] === color2[1] && color1[2] === color2[2];
        }

        // Convert hex color string to RGB array
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [0, 0, 0]; // Default to black if invalid hex
        }

        // Handle special tool clicks (Eyedropper, Bucket)
        canvas.addEventListener('click', (e) => {
            const { x, y } = getTransformedCoords(e);

            if (currentTool === 'eyedropper') {
                const color = getColorAtPosition(x, y);
                foregroundColor = color;
                document.getElementById('foregroundColor').value = color;
                updateBrushPreview(); // Update preview with new foreground color
            } else if (currentTool === 'bucket') {
                floodFill(x, y, foregroundColor);
                saveState(); // Save state after fill operation
            } else if (currentTool === 'zoom') {
                // Click to zoom in/out
                const oldZoomLevel = zoomLevel;
                const zoomFactor = e.shiftKey ? 0.9 : 1.1; // Shift+click to zoom out, click to zoom in
                zoomLevel = Math.max(0.1, Math.min(5.0, zoomLevel * zoomFactor));

                const rect = canvasWrapper.getBoundingClientRect();
                const mouseCanvasX = e.clientX - rect.left;
                const mouseCanvasY = e.clientY - rect.top;

                panX = mouseCanvasX - ((mouseCanvasX - panX) * (zoomLevel / oldZoomLevel));
                panY = mouseCanvasY - ((mouseCanvasY - panY) * (zoomLevel / oldZoomLevel));
                updateCanvasTransform();
            }
        });

        // Layer functionality (basic - currently just active state, no actual layer manipulation)
        document.querySelectorAll('.layer-item').forEach(layer => {
            layer.addEventListener('click', () => {
                document.querySelector('.layer-item.active').classList.remove('active');
                layer.classList.add('active');
            });
        });

        // Canvas size adjustment
        const canvasWidthInput = document.getElementById('canvasWidthInput');
        const canvasHeightInput = document.getElementById('canvasHeightInput');
        const applyCanvasSizeBtn = document.getElementById('applyCanvasSizeBtn');

        applyCanvasSizeBtn.addEventListener('click', applyCanvasSize);

        function applyCanvasSize() {
            const newWidth = parseInt(canvasWidthInput.value);
            const newHeight = parseInt(canvasHeightInput.value);

            if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 100 || newHeight < 100) {
                // Replaced alert with custom modal for user feedback
                showCustomConfirmation('Invalid Dimensions', 'Please enter valid numbers for width and height (min 100px).', () => {}, true); // No confirm callback, just dismiss
                return;
            }

            // Create a temporary canvas to hold the current image data
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0); // Draw current content to temp canvas

            // Resize the main canvas
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Clear the main canvas with background color before drawing old content
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw the content from the temporary canvas onto the new, resized main canvas
            // This will scale the content to fit the new dimensions
            ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, canvas.width, canvas.height);

            document.getElementById('canvasSize').textContent = `${canvas.width} √ó ${canvas.height} px`;
            saveState(); // Save the new canvas size and content
        }

        // Export with different formats
        function exportCanvas(format = 'png', quality = 1.0) {
            const link = document.createElement('a');
            link.download = `canvas-export-${Date.now()}.${format}`;

            if (format === 'jpg' || format === 'jpeg') {
                // Create a temporary canvas with a white background for JPEG export
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                tempCtx.fillStyle = '#ffffff'; // White background for JPEG
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(canvas, 0, 0); // Draw existing canvas content on top
                link.href = tempCanvas.toDataURL(`image/${format}`, quality);
            } else {
                link.href = canvas.toDataURL(`image/${format}`, quality);
            }
            link.click();
        }

        // Initial setup calls
        initCanvas();
        updateBrushPreview();
        updateBrushInfo();
        updateCanvasTransform(); // Initialize the transform

        // Auto-save functionality (every 30 seconds)
        setInterval(() => {
            const autoSaveData = canvas.toDataURL();
            try {
                // In a real application, this would save to a database or local storage.
                // For this demo, we'll just log it to console.
                console.log('Auto-save completed (data not actually stored)');
            } catch (e) {
                console.log('Auto-save skipped (error or no storage available)');
            }
        }, 30000);

        console.log('Canvas Studio Professional initialized successfully!');
    </script>
</body>

</html>
